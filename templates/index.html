<!DOCTYPE html>
<html>
<head>
    <title>Mouse Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            background-color: #000000;
            color: #ffffff;
            margin: 0;
            padding: 15px;
            font-family: monospace;
        }

        .logo {
            position: fixed;
            top: 15px;
            left: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            opacity: 0.8;
            z-index: 1000;
        }

        #touchpad {
            width: 100%;
            height: 300px;
            background: #000000;
            touch-action: none;
            border-radius: 20px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }

        .dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffffff;
            border-radius: 50%;
            transition: opacity 0.2s ease-out;
        }

        .button {
            padding: 12px 20px;
            margin: 5px;
            background: none;
            border: none;
            font-size: 16px;
            color: #ffffff;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            font-family: monospace;
        }

        .button:hover {
            opacity: 0.9;
        }

        .button:active {
            opacity: 1;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 15px;
            margin: 15px 0;
        }

        #networkStatus {
            padding: 12px;
            margin: 15px 0;
            border-radius: 8px;
            background: none;
            border: 1px solid rgba(255,255,255,0.1);
            font-family: monospace;
        }

        .connected {
            border-color: rgba(255,255,255,0.3) !important;
        }

        .disconnected {
            border-color: rgba(255,255,255,0.1) !important;
        }

        #virtual-keyboard {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #000000;
            padding: 15px;
            display: none;
            z-index: 1001;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        #keyboard-input {
            width: 100%;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 16px;
            background: #000000;
            color: #ffffff;
            font-family: monospace;
        }

        .settings-container {
            padding: 15px;
            margin: 15px 0 25px 0;  /* Increased bottom margin */
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .settings-container label {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .settings-container input[type="range"] {
            width: 200px;
            height: 2px;
            background: rgba(255,255,255,0.3);
            opacity: 0.3;
            border-radius: 1px;
            appearance: none;
            -webkit-appearance: none;
            transition: opacity 0.3s ease, background-color 0.3s ease;
        }

        .settings-container input[type="range"]:focus,
        .settings-container input[type="range"]:active {
            opacity: 1;
            background: #ffffff;
            outline: none;
        }

        .settings-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .settings-container input[type="range"]:focus::-webkit-slider-thumb,
        .settings-container input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
        }

        #sensitivityValue {
            min-width: 30px;
            text-align: right;
        }

        .kill-switch {
            position: fixed;
            top: 15px;
            right: 15px;
            background: none;
            color: #ffffff;
            border: none;
            padding: 12px 20px;
            cursor: pointer;
            font-weight: bold;
            z-index: 1000;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            font-family: monospace;
        }

        .kill-switch:hover {
            opacity: 0.9;
        }

        .kill-switch:active {
            opacity: 1;
        }

        .touch-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 2;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Piper</div>
        <button class="kill-switch" id="killSwitch">⚡ Kill Server</button>
    </div>
    <div id="networkStatus">Checking network connection...</div>
    <div class="settings-container">
        <label>
            Speed: <input type="range" id="sensitivity" min="0.5" max="5" step="0.1" value="2.5">
            <span id="sensitivityValue">2.5</span>
        </label>
    </div>
    <div id="touchpad"></div>
    <div class="button-container">
        <button class="button" id="rightClick">Right Click</button>
        <button class="button" id="keyboardToggle">⌨️ Keyboard</button>
    </div>
    
    <div id="virtual-keyboard">
        <input type="text" id="keyboard-input" placeholder="Type here... (characters will appear as you type)">
    </div>

    <script>
        const touchpad = document.getElementById('touchpad');
        let lastX = 0;
        let lastY = 0;
        let lastClickTime = 0;
        let lastMoveTime = 0;
        const doubleClickDelay = 300; // milliseconds
        let moveQueue = null;
        let movementHistory = [];
        const historySize = 5;

        // Movement settings
        let baseSpeed = 2.5;
        let acceleration = 1.0;
        const maxSpeed = 10;
        const accelerationThreshold = 50; // ms

        document.getElementById('sensitivity').addEventListener('input', (e) => {
            const slider = e.target;
            baseSpeed = parseFloat(slider.value);
            document.getElementById('sensitivityValue').textContent = baseSpeed.toFixed(1);
            slider.style.opacity = '1';
            slider.style.background = '#ffffff';
        });

        document.getElementById('sensitivity').addEventListener('blur', (e) => {
            const slider = e.target;
            slider.style.opacity = '0.3';
            slider.style.background = 'rgba(255,255,255,0.3)';
        });

        // Update movement settings for better responsiveness
        const minSpeed = 0.8;
        const accelerationFactor = 1.3;
        const smoothingFactor = 0.6;
        const movementThreshold = 0.05;
        let currentSpeed = baseSpeed;
        
        function calculateSmoothedMovement(dx, dy) {
            // Add current movement to history with timestamp
            const now = Date.now();
            movementHistory.unshift({ dx, dy, time: now });
            if (movementHistory.length > historySize) {
                movementHistory.pop();
            }

            // Calculate velocity-based smoothing
            let smoothX = 0;
            let smoothY = 0;
            let totalWeight = 0;
            let velocity = 0;
            
            movementHistory.forEach((move, index) => {
                const age = now - move.time;
                const weight = Math.pow(smoothingFactor, index);
                smoothX += move.dx * weight;
                smoothY += move.dy * weight;
                totalWeight += weight;
                
                if (index === 0) {
                    velocity = Math.hypot(move.dx, move.dy);
                }
            });

            // Apply non-linear acceleration based on movement speed
            const normalizedVelocity = Math.min(1, velocity / 50);
            currentSpeed = baseSpeed + (maxSpeed - baseSpeed) * Math.pow(normalizedVelocity, 2);
            
            // Apply speed limits
            currentSpeed = Math.max(minSpeed, Math.min(maxSpeed, currentSpeed));

            return {
                x: (smoothX / totalWeight) * currentSpeed,
                y: (smoothY / totalWeight) * currentSpeed
            };
        }

        function calculateAcceleration(currentTime) {
            const timeDelta = currentTime - lastMoveTime;
            if (timeDelta < accelerationThreshold) {
                acceleration = Math.min(acceleration * 1.2, maxSpeed / baseSpeed);
            } else {
                acceleration = Math.max(1.0, acceleration * 0.8);
            }
            lastMoveTime = currentTime;
            return acceleration;
        }

        // Update movement processing for better responsiveness
        function processMoveQueue() {
            if (moveQueue) {
                const magnitude = Math.hypot(moveQueue.x, moveQueue.y);
                if (magnitude > movementThreshold) {
                    // Normalize and apply enhanced movement
                    const scale = Math.pow(magnitude, 0.8); // Reduced power curve for more control
                    moveQueue.x = (moveQueue.x / magnitude) * scale;
                    moveQueue.y = (moveQueue.y / magnitude) * scale;
                    
                    safeFetch(`${serverAddress}/move`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(moveQueue)
                    });
                }
                moveQueue = null;
            }
            requestAnimationFrame(processMoveQueue);
        }
        requestAnimationFrame(processMoveQueue);

        // Create dots pattern
        function createDots() {
            // Remove existing dots
            const existingDots = document.querySelectorAll('.dot');
            existingDots.forEach(dot => dot.remove());

            const spacing = 20; // Smaller spacing between dots
            const touchpadRect = touchpad.getBoundingClientRect();
            const rows = Math.floor(touchpadRect.height / spacing);
            const cols = Math.floor(touchpadRect.width / spacing);
            
            // Calculate margins to center the grid
            const marginLeft = (touchpadRect.width - (cols * spacing)) / 2;
            const marginTop = (touchpadRect.height - (rows * spacing)) / 2;

            // Create symmetric grid of dots
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dot.style.left = `${marginLeft + (col * spacing)}px`;
                    dot.style.top = `${marginTop + (row * spacing)}px`;
                    touchpad.appendChild(dot);
                }
            }
        }

        function updateDotsOpacity(x, y) {
            const dots = document.querySelectorAll('.dot');
            const touchRect = touchpad.getBoundingClientRect();
            
            dots.forEach(dot => {
                const dotRect = dot.getBoundingClientRect();
                const dotX = dotRect.left - touchRect.left;
                const dotY = dotRect.top - touchRect.top;
                const distance = Math.hypot(x - dotX, y - dotY);
                
                if (distance < 40) { // Smaller radius for closer dots
                    const opacity = Math.min(1, 2 - (distance / 20)); // Sharper falloff
                    dot.style.opacity = opacity;
                    dot.classList.add('active');
                } else {
                    dot.style.opacity = 0.05; // Very low default opacity
                    dot.classList.remove('active');
                }
            });
        }

        // Call createDots initially
        createDots();

        // Recreate dots when window is resized
        window.addEventListener('resize', createDots);

        // Add touch point visualization
        function createTouchPoint(x, y) {
            const point = document.createElement('div');
            point.className = 'touch-point';
            point.style.left = `${x}px`;
            point.style.top = `${y}px`;
            touchpad.appendChild(point);
            return point;
        }

        touchpad.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            lastX = e.clientX;
            lastY = e.clientY;
            
            const touchRect = touchpad.getBoundingClientRect();
            const x = e.clientX - touchRect.left;
            const y = e.clientY - touchRect.top;
            
            updateDotsOpacity(x, y);
            createTouchPoint(x, y);
        });

        touchpad.addEventListener('pointermove', (e) => {
            e.preventDefault();
            if (e.buttons > 0) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                // Apply improved movement calculation
                const smoothedMovement = calculateSmoothedMovement(deltaX, deltaY);
                
                moveQueue = {
                    x: smoothedMovement.x,
                    y: smoothedMovement.y,
                    relative: true
                };

                lastX = e.clientX;
                lastY = e.clientY;

                // Update touch point visualization
                const touchRect = touchpad.getBoundingClientRect();
                const x = e.clientX - touchRect.left;
                const y = e.clientY - touchRect.top;
                
                // Remove old touch points
                const points = document.querySelectorAll('.touch-point');
                points.forEach(point => point.remove());
                
                createTouchPoint(x, y);

                // Update dots opacity
                updateDotsOpacity(x, y);
            }
        });

        touchpad.addEventListener('pointerup', (e) => {
            const currentTime = new Date().getTime();
            if (currentTime - lastClickTime < doubleClickDelay) {
                // Double click detected - trigger left click
                safeFetch(`${serverAddress}/click`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ button: 'left' })
                });
                lastClickTime = 0; // Reset to prevent triple-click
            } else {
                lastClickTime = currentTime;
            }
            
            // Reset all dots to low opacity
            const dots = document.querySelectorAll('.dot');
            dots.forEach(dot => {
                dot.style.opacity = 0.05;
                dot.classList.remove('active');
            });

            // Remove touch points
            const points = document.querySelectorAll('.touch-point');
            points.forEach(point => point.remove());
        });

        document.getElementById('rightClick').addEventListener('click', () => {
            safeFetch(`${serverAddress}/click`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    button: 'right'
                })
            });
        });

        // Simplified keyboard handling
        document.getElementById('keyboardToggle').addEventListener('click', () => {
            const keyboard = document.getElementById('virtual-keyboard');
            const keyboardInput = document.getElementById('keyboard-input');
            const isVisible = keyboard.style.display === 'block';
            
            if (isVisible) {
                // Hiding keyboard
                keyboard.style.display = 'none';
                keyboardInput.value = '';
                lastInputValue = '';
            } else {
                // Showing keyboard
                keyboard.style.display = 'block';
                keyboardInput.value = '';
                lastInputValue = '';
                keyboardInput.focus();
            }
        });

        // Real-time character streaming
        let lastInputValue = '';
        document.getElementById('keyboard-input').addEventListener('input', (e) => {
            const currentValue = e.target.value;
            const lastChar = currentValue.slice(lastInputValue.length);
            
            if (currentValue.length > lastInputValue.length) {
                safeFetch(`${serverAddress}/type`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: lastChar })
                });
            } else if (currentValue.length < lastInputValue.length) {
                safeFetch(`${serverAddress}/type`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '{BACKSPACE}' })
                });
            }
            
            lastInputValue = currentValue;
        });

        // Handle special keys
        document.getElementById('keyboard-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                safeFetch(`${serverAddress}/type`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: '{ENTER}' })
                });
                e.preventDefault();
            }
        });

        // Add keyboard blur handler
        document.getElementById('keyboard-input').addEventListener('blur', () => {
            const keyboard = document.getElementById('virtual-keyboard');
            keyboard.style.display = 'none';
            document.getElementById('keyboard-input').value = '';
            lastInputValue = '';
        });

        const serverAddress = window.location.origin;
        let isConnected = false;

        // Improved network check function
        async function checkNetwork() {
            try {
                const response = await fetch(`${serverAddress}/network-check`);
                if (!response.ok) throw new Error('Network response was not ok');
                
                const data = await response.json();
                const statusDiv = document.getElementById('networkStatus');
                
                if (data.status === 'connected') {
                    statusDiv.innerHTML = `Connected! Your IP: ${data.client_ip}<br>Server IP: ${data.server_ip}`;
                    statusDiv.className = 'connected';
                    isConnected = true;
                    document.getElementById('touchpad').style.pointerEvents = 'auto';
                    
                    // Auto-hide successful connection message after 3 seconds
                    setTimeout(() => {
                        if (isConnected) {
                            statusDiv.style.display = 'none';
                        }
                    }, 3000);
                } else {
                    throw new Error(data.error || 'Unknown connection error');
                }
            } catch (error) {
                console.error('Network check error:', error);
                const statusDiv = document.getElementById('networkStatus');
                statusDiv.style.display = 'block'; // Always show error messages
                statusDiv.innerHTML = `Connection error! ${error.message}<br>Try refreshing the page.`;
                statusDiv.className = 'disconnected';
                isConnected = false;
                document.getElementById('touchpad').style.pointerEvents = 'none';
            }
        }

        // Check network more frequently at start, then slow down
        async function startNetworkChecks() {
            // Check immediately
            await checkNetwork();
            
            // Check every second for the first 5 seconds
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                if (isConnected) break;
                await checkNetwork();
            }
            
            // If still not connected, check every 5 seconds
            if (!isConnected) {
                setInterval(checkNetwork, 5000);
            }
        }

        // Start network checks
        startNetworkChecks();

        // Add error handling to fetch requests
        function safeFetch(url, options) {
            return fetch(url, options).catch(error => {
                console.error('Fetch error:', error);
                checkNetwork(); // Recheck network status on error
                throw error;
            });
        }

        // Add kill switch handler
        document.getElementById('killSwitch').addEventListener('click', async () => {
            if (confirm('Are you sure you want to shut down the server? This will stop the remote control.')) {
                try {
                    await safeFetch(`${serverAddress}/kill`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    document.body.innerHTML = '<h1 style="text-align:center;margin-top:50px;">Server shutdown successful. You can close this window.</h1>';
                } catch (error) {
                    alert('Error shutting down server: ' + error.message);
                }
            }
        });

        // Add keyboard shortcut for kill switch
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'K') {
                document.getElementById('killSwitch').click();
            }
        });

        // Add double-tap detection for mobile
        let lastTapTime = 0;
        touchpad.addEventListener('touchend', (e) => {
            const currentTime = Date.now();
            const tapLength = currentTime - lastTapTime;
            if (tapLength < 500 && tapLength > 0) {
                safeFetch(`${serverAddress}/click`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ button: 'left' })
                });
            }
            lastTapTime = currentTime;
        });

        // Prevent zooming on double tap
        document.addEventListener('touchend', (e) => {
            const now = Date.now();
            if (now - lastTapTime < 300) {
                e.preventDefault();
            }
            lastTapTime = now;
        }, { passive: false });

        // Prevent pinch zoom
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
